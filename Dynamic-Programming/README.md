# Programacao Dinamica

Tecnica para resolver problemas complexos dividindo-os em subproblemas sobrepostos e armazenando resultados.

## Algoritmos Implementados

1. **Fibonacci** - Sequencia classica
2. **LCS (Longest Common Subsequence)** - Maior subsequencia comum
3. **0/1 Knapsack** - Problema da mochila
4. **Matrix Chain Multiplication** - Ordem otima de multiplicacao
5. **Coin Change** - Minimo de moedas para troco

## Conceitos Fundamentais

### Programacao Dinamica
Otimizacao que armazena resultados de subproblemas para evitar recalculo.

### Memoizacao vs Tabulacao

**Memoizacao (Top-Down):**
- Recursivo
- Calcula sob demanda
- Usa cache (dicionario)

**Tabulacao (Bottom-Up):**
- Iterativo
- Calcula todos os subproblemas
- Usa array

### Quando Usar DP

1. **Subproblemas Sobrepostos:** Mesmo subproblema aparece multiplas vezes
2. **Subestrutura Otima:** Solucao otima contem solucoes otimas de subproblemas

## Aplicacoes

### Fibonacci
- Introducao a DP
- Crescimento populacional
- Sequencias matematicas

### LCS
- Diff de arquivos (git diff)
- Bioinformatica (DNA)
- Deteccao de plagio

### Knapsack
- Alocacao de recursos
- Selecao de investimentos
- Planejamento de projetos

### Matrix Chain
- Otimizacao de consultas DB
- Computacao grafica
- Algebra linear

### Coin Change
- Sistemas de pagamento
- Otimizacao financeira
- Logistica

## Complexidade

| Problema | Recursao Ingênua | DP |
|----------|------------------|-----|
| Fibonacci | O(2^n) | O(n) |
| LCS | O(2^(m+n)) | O(m*n) |
| Knapsack | O(2^n) | O(n*W) |

## Referencias

- Cormen et al., "Introduction to Algorithms", Cap. 15
- Skiena, "The Algorithm Design Manual", Cap. 8


Tecnica para resolver problemas complexos dividindo-os em subproblemas sobrepostos e armazenando resultados.

## Algoritmos Implementados

1. **Fibonacci** - Sequencia classica
2. **LCS (Longest Common Subsequence)** - Maior subsequencia comum
3. **0/1 Knapsack** - Problema da mochila
4. **Matrix Chain Multiplication** - Ordem otima de multiplicacao
5. **Coin Change** - Minimo de moedas para troco

## Conceitos Fundamentais

### Programacao Dinamica
Otimizacao que armazena resultados de subproblemas para evitar recalculo.

### Memoizacao vs Tabulacao

**Memoizacao (Top-Down):**
- Recursivo
- Calcula sob demanda
- Usa cache (dicionario)

**Tabulacao (Bottom-Up):**
- Iterativo
- Calcula todos os subproblemas
- Usa array

### Quando Usar DP

1. **Subproblemas Sobrepostos:** Mesmo subproblema aparece multiplas vezes
2. **Subestrutura Otima:** Solucao otima contem solucoes otimas de subproblemas

## Aplicacoes

### Fibonacci
- Introducao a DP
- Crescimento populacional
- Sequencias matematicas

### LCS
- Diff de arquivos (git diff)
- Bioinformatica (DNA)
- Deteccao de plagio

### Knapsack
- Alocacao de recursos
- Selecao de investimentos
- Planejamento de projetos

### Matrix Chain
- Otimizacao de consultas DB
- Computacao grafica
- Algebra linear

### Coin Change
- Sistemas de pagamento
- Otimizacao financeira
- Logistica

## Complexidade

| Problema | Recursao Ingênua | DP |
|----------|------------------|-----|
| Fibonacci | O(2^n) | O(n) |
| LCS | O(2^(m+n)) | O(m*n) |
| Knapsack | O(2^n) | O(n*W) |

## Referencias

- Cormen et al., "Introduction to Algorithms", Cap. 15
- Skiena, "The Algorithm Design Manual", Cap. 8



